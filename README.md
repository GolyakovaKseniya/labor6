# Задание 1
## Задача 1
### Текст задачи
@Invoke. Разработайте аннотацию @Invoke, со следующими характеристиками: • Целью может быть только МЕТОД • Доступна во время исполнения программы • Не имеет свойств Создайте класс, содержащий несколько методов, и проаннотируйте хотя бы один из них аннотацией @Invoke. Реализуйте обработчик (через Reflection API), который находит методы, отмеченные аннотацией @Invoke, и вызывает их автоматически.
### Алгоритм решения
Создадим аннотацию @Invoke, которая может применяться только к методам и доступна во время выполнения программы. По условию задачи аннотация не имеет свойств, то есть она маркерная аннотация. Создадим класс Person с 2 полями: имя и возраст, пропишем конструктор, метод без параметров, который выводит приветствие в консоль, и метод toString. Проаннотируем метод, выводящий приветствие. Далее пропишем обработчик, который принимает объект, определяет его класс и перебираем все методы, которые в нем есть. Потом проверяем есть ли у текущего метода аннотация @Invoke, если есть – выводит имя этого метода, делаем его доступным для вызова. Пытаемся вызвать найденный метод на объекте. Если не получилось выведем ошибку.
#### Пример вывода
1) 


# Задание 1
## Задача 2
### Текст задачи
@Default. Разработайте аннотацию @Default, со следующими характеристиками: • Целью может быть ТИП или ПОЛЕ • Доступна во время исполнения программы • Имеет обязательное свойство value типа Class Проаннотируйте какой-либо класс данной аннотацией, указав тип по умолчанию. Напишите обработчик, который выводит имя указанного класса по умолчанию.
### Алгоритм решения
Создадим аннотацию @Default, которая может применяться к полю или типу (класс/интерфейс) и доступна во время выполнения программы. По условию задачи аннотация имеет обязательное свойство value() типа Class<?>, это единственный параметр – класс типа. Создадим класс User с 3 полями: возраст, зарплата и имя. Пропишем конструктор по умолчанию и метод toString. Проаннотируем этот класс, типом по умолчанию для этого класса будет он сам. Также проаннотируем поля с возрастом и зарплатой. То есть поле имя не имеет типа по умолчанию (Object). Далее пропишем обработчик, который принимает объект типового класса. Проверяем есть ли у переданного класса аннотация @Default, если она есть – получаем ее, далее получаем и выводим значение параметра value(), то есть тип по умолчанию, если нет – выводим об этом сообщение.
#### Пример вывода
1)



# Задание 1
## Задача 3
### Текст задачи
@ToString. Разработайте аннотацию @ToString, со следующими характеристиками: • Целью может быть ТИП или ПОЛЕ • Доступна во время исполнения программы • Имеет необязательное свойство valuec двумя вариантами значений: YES или NO • Значение свойства по умолчанию: YES Проаннотируйте класс аннотацией @ToString, а одно из полей – с @ToString(Mode.NO). Создайте метод, который формирует строковое представление объекта, учитывая только те поля, где @ToString имеет значение YES.
### Алгоритм решения
Чтобы создать аннотацию toString, сначала создадим перечисление (Enum) для режимов отображения с 2 параметрами: yes (включить в строковое представление) и no (исключить). Аннотация может применяться только к типам и полям и доступна во время выполнения программы. Имеет одно необязательное свойство value() (default) с типом Mode, по умолчанию будет стоять значение yes, если не указано явно. Создадим класс BankAccount с 3 полями: номер аккаунта, баланс и пин-код, с конструктором и геттерами. Проаннотируем сам класс без параметров (должен быть в строковом представлении) и поле пин-код с параметром Mode.No (должен быть исключен).  Далее пропишем обработчик, принимающий объект, получаем класс и его имя. Далее проверяем аннотация на классе. Если у класса есть параметр Mode.No, то возвращаем сокращенную форму. Для формирования строки используем StringBuilder, после записи имени класса получаем все его поля и перебираем их. Делаем каждое поле доступным и получаем для него аннотацию. Далее проверяем, если аннотации в принципе нет или она с параметром Mode.Yes, то добавляем запятую между полями. Потом получаем имя и значение текущего поля. И добавляем в результат.
#### Пример вывода
1)
2)

# Задание 1
## Задача 4
### Текст задачи
@Validate. Разработайте аннотацию @Validate, со следующими характеристиками: • Целью может быть ТИП или АННОТАЦИЯ • Доступна во время исполнения программы • Имеет обязательное свойство value, типа Class[] Проаннотируйте класс аннотацией @Validate, передав список типов для проверки. Реализуйте обработчик, который выводит, какие классы указаны в аннотации.
### Алгоритм решения
Создадим аннотацию @Validate, которая может применяться к типу или аннотации и доступна во время выполнения программы. По условию имеет обязательное свойство value() типа Class<?>[] (массив классов). Проаннотируем уже существующий класс Person параметрами String.class и Integer.class. Остальное в классе не меняется. Пропишем обработчик, принимающий объект, представляющий тип во время исполнения. Получаем аннотацию у переданного класса, проверяем, если ее нет, то выводим об этом сообщение, если она есть – получаем массив классов из аннотации, и для каждого выводим его имя.
#### Пример вывода
1)
2)


# Задание 1
## Задача 5
### Текст задачи
@Two. Разработайте аннотацию @Two, со следующими характеристиками: • Целью может быть ТИП • Доступна во время исполнения программы • Имеет два обязательных свойства: first типа String и second типа int Проаннотируйте какой-либо класс аннотацией @Two, передав строковое и числовое значения. Реализуйте обработчик, который считывает и выводит значения этих свойств.
### Алгоритм решения
Создадим аннотацию @Two, которая может применяться к типу и доступна во время выполнения программы. По условию имеет 2 обязательных свойства: first – тип String, second – тип int. Создадим класс Point с 2 полями: координаты х и у, с конструктором и геттерами/сеттерами и методом toString. Проаннотируем этот класс с указанием обоих параметров. Пусть это будут first = “Координаты точки”, second = 100. Остальные методы в классе не изменяются. Далее пропишем обработчик, принимающий представление класса во время выполнения. В нем получаем аннотацию у переданного класса. Если аннотации нет, то выведем сообщение об этом, иначе получаем и выводим значение 1 параметра и также со 2 параметром. 
#### Пример вывода
1) 

# Задание 1
## Задача 6
### Текст задачи
@Cache. Разработайте аннотацию @Cache, со следующими характеристиками: • Целью может быть ТИП • Доступна во время исполнения программы • Имеет необязательное свойство value, типа String[] • Значение свойства по умолчанию: пустой массив Проаннотируйте класс аннотацией @Cache, указав несколько кешируемых областей. Создайте обработчик, который выводит список всех кешируемых областей или сообщение, что список пуст.
### Алгоритм решения
Создадим аннотацию @Cache, которая может применяться только к типу и доступна во время выполнения программы. По условию имеет необязательное свойство value() (default) типа массив строк. По условию значение необязательного свойства – пустой массив. Проаннотируем класс BankAccount с указанием трех областей кэширования: account_balance, account_details, transactions. Все остальное в классе не меняется. Пропишем обработчик, который принимает объект представления класса, получаем аннотацию у переданного класса. Если аннотации нет, то выводим об этом сообщение, иначе получаем массив областей. Далее проверяем массив на пустоту, если пуст – выводим сообщение, иначе выводим количество кэшируемых областей и их самих. 
#### Пример вывода
1)
2)

# Задание 2
## Задача 1
### Текст задачи
Напишите тест, используя фреймворк JUnit, к методу toString() (или методу, формирующему строковое представление объекта, основанное на аннотации @ToString). • Проверить, что в результирующей строке отображаются только те поля, которые имеют аннотацию @ToString(Mode.YES) или не аннотированы вовсе. • Убедиться, что поля с @ToString(Mode.NO) не попадают в вывод.
### Алгоритм решения
Создадим класс для тестирования. JUnit – фреймворк для модульного тестирования. Используем аннотацию @Test, которая помечает метод как тест, и Junit автоматически запускает такие методы. Пропишем первый тестовый метод, который проверяет корректно ли обработчик метода toString включает поля accountNumber и balance. В нем создаем объект класса BankAccount с тестовыми данными, объект класса AnnotationHandler, который содержит метод с обработчиком. Далее вызываем этот метод для объекта класса BankAccount. Далее проверяем: 
1) строка содержит номер счета. Если результирующая строка содержит номер, то тест проходит, иначе - нет
2) строка содержит баланс. Если результирующая строка содержит баланс, то тест проходит, иначе нет.
Потом пропишем второй тестовый метод, который проверяет, исключает ли обработчик метода toString поле pinCode. Также создаем объекты классов BankAccount (с тестовыми данными) и AnnotationHandler. Далее вызываем метод обработчика для объекта. Далее проверяем: 
1) строка не содержит поле pinCode. Если результирующая строка не содержит пинкод, то тест проходит, иначе – нет
2) доп проверка, строка не содержит и значение пинкода. Если не содержит, то тест проходит, иначе – нет.
#### Пример вывода
1)

# Задание 2
## Задача 5
### Текст задачи
Реализовать тест, используя фреймворк JUnit, для класса, использующего аннотацию @Cache. • Проверить, что список кешируемых сущностей (value) корректно считывается. • Реализовать мок-тест (с использованием Mockito или встроенных подстановок), имитирующий обращение к кешу. • Проверить, что если массив пуст – кеширование не производится. • Добавить отдельный тест для случая, когда кеш содержит несколько именованных областей.
### Алгоритм решения
Создадим класс для теста. По условию должен быть тест Мок – включаем его поддержку. Пропишем первый тест (@Test), который проверяет, что список сущностей корректно считывается. В нем получаем аннотацию у класса BankAccount, далее проверяем что аннотация существует, далее проверяем значения, сравниваем ожидаемые и те, что в аннотации. Второй тест – работа с Мockito. Для этого объявим аннотацию @Mock, которая создает «фейковый» объект CacheManager (его имитацию). В интерфейсе CacheManager (Mockito не может работать с классами без доп настроек) объявим метод, который вернет строку из имени области кэширования и ключа для поиска в кэше. В методе настраиваем Мок, в нем, если метод get() вызван с параметрами "account_balance", "acc123", то должен вернуть "cached_data", иначе вернет null. Далее вызываем этот метод на моке и проверяем, что он был вызван ровно 1 раз с данными аргументами. И проверяем, что результат совпадает с ожидаемым. Далее пропишем третий тест, проверяет, что аннотация корректно работает с пустым массивом. В нем создадим локальный класс с пустой аннотацией, потом получаем ее и проверяем, что массив пустой. Далее 4 тест для кэша с несколькими областями. В нем создадим локальный класс с 3 областями, получаем аннотацию, проверяем количество областей и конкретные значения.
#### Пример вывода



